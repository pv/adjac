!! NOTE: this file is autogenerated from adjac.f95.in: do not edit manually
! -*-f90-*-
!
! adjac: Automatic Differentiation for generating Jacobians.
!

! Copyright (c) 2014, Pauli Virtanen <pav@iki.fi>
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions
! are met:
!
! 1. Redistributions of source code must retain the above copyright
! notice, this list of conditions and the following disclaimer.
!
! 2. Redistributions in binary form must reproduce the above copyright
! notice, this list of conditions and the following disclaimer in the
! documentation and/or other materials provided with the distribution.
!
! 3. Neither the name of the copyright holder nor the names of its
! contributors may be used to endorse or promote products derived from
! this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
! FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
! COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
! INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
! BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
! LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
! ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
! POSSIBILITY OF SUCH DAMAGE.

module adjac
  private

  ! NOTE: we would like to use derived type finalizers for memory
  ! deallocation.  However, as of 2015-03-12, these are not fully
  ! implemented in gfortran, and will not be called e.g. on function
  ! returns that the code here extensively relies on.

  type, public :: adjac_double
     double precision :: value, vmul
     integer :: n = 0
     double precision, dimension(:), allocatable :: v
     integer, dimension(:), allocatable :: i
  end type adjac_double

  type, public :: adjac_complexan
     double complex :: value, vmul
     integer :: n = 0
     double complex, dimension(:), allocatable :: v
     integer, dimension(:), allocatable :: i
  end type adjac_complexan

  type, public :: adjac_complex
     type(adjac_double) :: re, im
  end type adjac_complex

  logical :: jac_product_mode = .false.

  public assignment(=)
  interface assignment(=)
     module procedure assign_ai, assign_ad
     module procedure assign_bi, assign_bd, assign_bz, assign_ba
     module procedure assign_qi, assign_qd, assign_qz
  end interface

  public operator(+)
  interface operator(+)
     module procedure add_aa
     module procedure add_bb
     module procedure add_qq
     module procedure add_ab
     module procedure add_ba
     module procedure add_ai
     module procedure add_bi
     module procedure add_qi
     module procedure add_ia
     module procedure add_ib
     module procedure add_iq
     module procedure add_ad
     module procedure add_bd
     module procedure add_qd
     module procedure add_da
     module procedure add_db
     module procedure add_dq
     module procedure add_az
     module procedure add_bz
     module procedure add_qz
     module procedure add_za
     module procedure add_zb
     module procedure add_zq
     module procedure pos_a, pos_b, pos_q
  end interface

  public operator(-)
  interface operator(-)
     module procedure sub_aa
     module procedure sub_bb
     module procedure sub_qq
     module procedure sub_ab
     module procedure sub_ba
     module procedure sub_ai
     module procedure sub_bi
     module procedure sub_qi
     module procedure sub_ia
     module procedure sub_ib
     module procedure sub_iq
     module procedure sub_ad
     module procedure sub_bd
     module procedure sub_qd
     module procedure sub_da
     module procedure sub_db
     module procedure sub_dq
     module procedure sub_az
     module procedure sub_bz
     module procedure sub_qz
     module procedure sub_za
     module procedure sub_zb
     module procedure sub_zq
     module procedure neg_a, neg_b, neg_q
  end interface

  public operator(*)
  interface operator(*)
     module procedure mul_aa
     module procedure mul_bb
     module procedure mul_qq
     module procedure mul_ab
     module procedure mul_ba
     module procedure mul_ai
     module procedure mul_bi
     module procedure mul_qi
     module procedure mul_ia
     module procedure mul_ib
     module procedure mul_iq
     module procedure mul_ad
     module procedure mul_bd
     module procedure mul_qd
     module procedure mul_da
     module procedure mul_db
     module procedure mul_dq
     module procedure mul_az
     module procedure mul_bz
     module procedure mul_qz
     module procedure mul_za
     module procedure mul_zb
     module procedure mul_zq
  end interface operator(*)

  public operator(/)
  interface operator(/)
     module procedure div_aa
     module procedure div_bb
     module procedure div_qq
     module procedure div_ab
     module procedure div_ba
     module procedure div_ai
     module procedure div_bi
     module procedure div_qi
     module procedure div_ia
     module procedure div_ib
     module procedure div_iq
     module procedure div_ad
     module procedure div_bd
     module procedure div_qd
     module procedure div_da
     module procedure div_db
     module procedure div_dq
     module procedure div_az
     module procedure div_bz
     module procedure div_qz
     module procedure div_za
     module procedure div_zb
     module procedure div_zq
  end interface operator(/)

  public operator(**)
  interface operator(**)
     module procedure pow_ai, pow_ad, pow_qi, pow_qd, pow_qz
  end interface operator(**)

  public matmul
  interface matmul
     module procedure matmul_aa, matmul_ai, matmul_ia, matmul_ad, matmul_da
     module procedure matmul_bb, matmul_bz, matmul_zb
     module procedure matmul_qq, matmul_qi, matmul_iq, matmul_qd, matmul_dq, matmul_qz, matmul_zq
  end interface matmul

  public dble
  interface dble
     module procedure dble_a, dble_b
  end interface dble

  public aimag
  interface aimag
     module procedure aimag_b
  end interface aimag

  public conjg
  interface conjg
     module procedure conjg_b
  end interface conjg

  public exp
  interface exp
     module procedure exp_a, exp_b, exp_q
  end interface exp

  public sin
  interface sin
     module procedure sin_a, sin_b, sin_q
  end interface sin

  public cos
  interface cos
     module procedure cos_a, cos_b, cos_q
  end interface cos

  public log
  interface log
     module procedure log_a, log_b, log_q
  end interface log

  interface adjac_set_independent
     module procedure set_independent_a, set_independent_q
     module procedure set_independent_many_a, set_independent_many_q
  end interface adjac_set_independent

  interface sum_taylor
     module procedure sum_taylor_a, sum_taylor_q
  end interface sum_taylor

  interface adjac_get_value
     module procedure get_value_one_a, get_value_one_q
     module procedure get_value_many_a, get_value_many_q
  end interface adjac_get_value

  interface adjac_get_dense_jacobian
     module procedure get_dense_jacobian_a, get_dense_jacobian_q
  end interface adjac_get_dense_jacobian

  interface adjac_get_coo_jacobian
     module procedure get_coo_jacobian_a, get_coo_jacobian_q
  end interface adjac_get_coo_jacobian

  public adjac_set_independent, adjac_get_value, &
       adjac_get_dense_jacobian, adjac_get_coo_jacobian, &
       adjac_reset, adjac_free

contains

  subroutine fatal_error(msg)
    implicit none
    character(len=*), intent(in) :: msg
    write(*,*) 'adjac: error: ', trim(msg)
    stop
  end subroutine fatal_error

  subroutine adjac_reset(product_mode)
    implicit none
    logical, optional, intent(in) :: product_mode

    if (present(product_mode)) then
       jac_product_mode = product_mode
    end if
  end subroutine adjac_reset

  subroutine adjac_free()
    implicit none
  end subroutine adjac_free
  pure subroutine alloc_mem_a(x, n)
    implicit none
    type(adjac_double), intent(inout) :: x
    integer, intent(in) :: n

    if (jac_product_mode) then
       return
    end if
    x%n = n
    allocate(x%i(n), x%v(n))
  end subroutine alloc_mem_a

  pure subroutine link_mem_a(dst, src)
    implicit none
    type(adjac_double), intent(inout) :: dst
    type(adjac_double), intent(in) :: src
    dst%n = src%n
    if (src%n > 0) then
       dst%v = src%v
       dst%i = src%i
    end if
  end subroutine link_mem_a

  pure subroutine free_mem_a(x)
    implicit none
    type(adjac_double), intent(inout) :: x
    if (x%n > 0) then
       deallocate(x%v)
       deallocate(x%i)
    end if
    x%n = 0
  end subroutine free_mem_a

  subroutine set_independent_a(x, xval, j, dx)
    implicit none
    type(adjac_double), intent(out) :: x
    double precision, intent(in) :: xval
    double precision, optional, intent(in) :: dx
    integer, intent(in) :: j

    x%value = xval
    if (jac_product_mode) then
       if (.not.present(dx)) then
          call fatal_error('no dx given to adjac_set_independent when jacobian product mode is active')
       end if
       x%vmul = dx
    else
       x%vmul = 1
       call alloc_mem_a(x, 1)
       x%v(1) = 1
       x%i(1) = j
    end if
  end subroutine set_independent_a

  subroutine set_independent_many_a(x, xval, dx)
    implicit none
    type(adjac_double), dimension(:), intent(inout) :: x
    double precision, dimension(size(x)), intent(in) :: xval
    double precision, dimension(size(x)), optional, intent(in) :: dx

    integer :: j

    if (present(dx)) then
       do j = 1, size(x,1)
          call set_independent_a(x(j), xval(j), j, dx(j))
       end do
    else
       do j = 1, size(x,1)
          call set_independent_a(x(j), xval(j), j)
       end do
    end if
  end subroutine set_independent_many_a

  subroutine get_value_one_a(y, val, dy)
    implicit none
    type(adjac_double), intent(in) :: y
    double precision, intent(out) :: val
    double precision, optional, intent(out) :: dy
    val = y%value
    if (present(dy)) then
       if (.not. jac_product_mode) then
          call fatal_error('call to adjac_get_value with dy when jacobian product mode is not active')
       end if
       dy = y%vmul
    end if
  end subroutine get_value_one_a

  subroutine get_value_many_a(y, val, dy)
    implicit none
    type(adjac_double), dimension(:), intent(in) :: y
    double precision, dimension(size(y,1)), intent(out) :: val
    double precision, dimension(size(y,1)), optional, intent(out) :: dy
    integer :: j
    do j = 1, size(val,1)
       val(j) = y(j)%value
    end do
    if (present(dy)) then
       if (.not. jac_product_mode) then
          call fatal_error('call to adjac_get_value with dy when jacobian product mode is not active')
       end if
       do j = 1, size(val,1)
          dy(j) = y(j)%vmul
       end do
    end if
  end subroutine get_value_many_a

  subroutine get_dense_jacobian_a(y, jac_dense)
    implicit none
    type(adjac_double), dimension(:), intent(inout) :: y
    double precision, dimension(:,:), intent(out) :: jac_dense
    integer :: i, p

    if (jac_product_mode) then
       call fatal_error('call to adjac_get_dense_jacobian when jacobian product mode is active')
    end if

    jac_dense = 0

    do i = 1, size(y,1)
       do p = 1, y(i)%n
          jac_dense(i, y(i)%i(p)) = jac_dense(i, y(i)%i(p)) &
               + y(i)%vmul * y(i)%v(p)
       end do
    end do
  end subroutine get_dense_jacobian_a

  subroutine get_coo_jacobian_a(y, jac_val, jac_i, jac_j)
    implicit none
    type(adjac_double), dimension(:), intent(inout) :: y
    double precision, dimension(:), allocatable, intent(inout) :: jac_val
    integer, dimension(:), allocatable, intent(inout) :: jac_i, jac_j
    integer :: i, k, nnz

    if (jac_product_mode) then
       call fatal_error('call to adjac_get_coo_jacobian when jacobian product mode is active')
    end if

    if (allocated(jac_val)) deallocate(jac_val)
    if (allocated(jac_i)) deallocate(jac_i)
    if (allocated(jac_j)) deallocate(jac_j)

    nnz = sum(y%n)

    allocate(jac_val(nnz), jac_i(nnz), jac_j(nnz))

    k = 1
    do i = 1, size(y,1)
       if (y(i)%n > 0) then
          jac_i(k:k+y(i)%n-1) = i
          jac_j(k:k+y(i)%n-1) = y(i)%i(1:y(i)%n)
          jac_val(k:k+y(i)%n-1) = y(i)%vmul * y(i)%v(1:y(i)%n)
          k = k + y(i)%n
       end if
    end do
  end subroutine get_coo_jacobian_a

  pure subroutine sum_taylor_a(alphap, betap, a, b, c)
    ! c := alpha*a + beta*b
    use iso_c_binding
    implicit none
    double precision, intent(in) :: alphap, betap
    type(adjac_double), intent(in) :: a, b
    type(adjac_double), intent(inout) :: c
    interface
       pure subroutine sparse_vector_sum_a(alpha, beta, na, nb, nc, ia, ib, ic, va, vb, vc) &
            bind(C,name="sparse_vector_sum_a")
         use iso_c_binding
         integer(kind=c_int), intent(in) :: na, nb, ia(*), ib(*)
         integer(kind=c_int), intent(inout) :: nc
         integer(kind=c_int), intent(out) :: ic(*)
         real(kind=c_double), intent(in) :: alpha, beta, va(*), vb(*)
         real(kind=c_double), intent(out) :: vc(*)
       end subroutine sparse_vector_sum_a
    end interface

    if (jac_product_mode) then
       c%vmul = alphap * a%vmul + betap * b%vmul
    else
       call sparse_vector_sum_a(alphap*a%vmul, betap*b%vmul, a%n, b%n, c%n, &
            a%i, b%i, c%i, &
            a%v, b%v, c%v)
       c%vmul = 1
    end if
  end subroutine sum_taylor_a

  
  !--------------------------------------------------------------------------
  ! Overloaded operators
  !--------------------------------------------------------------------------

  !!
  !! assignment(=)
  !!

  pure elemental subroutine assign_ai(x, y)
    implicit none
    type(adjac_double), intent(inout) :: x
    integer, intent(in) :: y
    call free_mem_a(x)
    x%value = y
    x%vmul = 0
  end subroutine assign_ai
  pure elemental subroutine assign_ad(x, y)
    implicit none
    type(adjac_double), intent(inout) :: x
    double precision, intent(in) :: y
    call free_mem_a(x)
    x%value = y
    x%vmul = 0
  end subroutine assign_ad
  pure elemental subroutine assign_bi(x, y)
    implicit none
    type(adjac_complex), intent(inout) :: x
    integer, intent(in) :: y
    x%re = dble(y)
    x%im = 0d0
  end subroutine assign_bi
  pure elemental subroutine assign_bd(x, y)
    implicit none
    type(adjac_complex), intent(inout) :: x
    double precision, intent(in) :: y
    x%re = dble(y)
    x%im = 0d0
  end subroutine assign_bd

  pure elemental subroutine assign_bz(x, y)
    implicit none
    type(adjac_complex), intent(inout) :: x
    double complex, intent(in) :: y
    x%re = dble(y)
    x%im = aimag(y)
  end subroutine assign_bz

  pure elemental subroutine assign_ba(x, y)
    implicit none
    type(adjac_complex), intent(inout) :: x
    type(adjac_double), intent(in) :: y
    x%re = y
    x%im = 0d0
  end subroutine assign_ba

  !!
  !! operator(+)
  !!

  ! X + Y = x + y + (x_j + y_j) dj

  pure elemental function add_aa(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x, y
    type(adjac_double) :: z

    z%value = x%value + y%value
    call alloc_mem_a(z, x%n + y%n)
    call sum_taylor(dble(1d0), dble(1d0), x, y, z)
  end function add_aa

  pure elemental function add_ai(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_double) :: z
    z%value = x%value + y
    z%vmul = x%vmul
    call link_mem_a(z, x)
  end function add_ai

  pure elemental function add_ia(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_double) :: z
    z = y + x
  end function add_ia
  pure elemental function add_ad(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_double) :: z
    z%value = x%value + y
    z%vmul = x%vmul
    call link_mem_a(z, x)
  end function add_ad

  pure elemental function add_da(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_double) :: z
    z = y + x
  end function add_da
  pure elemental function add_az(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x + dble(y)
    z%im = aimag(y)
  end function add_az

  pure elemental function add_za(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) + y
    z%im = aimag(x)
  end function add_za

  pure elemental function add_bb(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re + y%re
    z%im = x%im + y%im
  end function add_bb

  pure elemental function add_bz(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re + dble(y)
    z%im = x%im + aimag(y)
  end function add_bz

  pure elemental function add_zb(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) + y%re
    z%im = aimag(x) + y%im
  end function add_zb

  pure elemental function add_ba(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re + y
    z%im = x%im
  end function add_ba

  pure elemental function add_ab(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x + y%re
    z%im = y%im
  end function add_ab

  pure elemental function add_bi(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_complex) :: z
    z = x + dcmplx(y)
  end function add_bi

  pure elemental function add_ib(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) + y
  end function add_ib
  pure elemental function add_bd(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_complex) :: z
    z = x + dcmplx(y)
  end function add_bd

  pure elemental function add_db(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) + y
  end function add_db

  !!
  !! operator(+), unary
  !!

  pure elemental function pos_a(x) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_double) :: z
    z = x
  end function pos_a

  pure elemental function pos_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    z = x
  end function pos_b

  !!
  !! operator(-)
  !!

  ! X - Y = x - y + (x_j - y_j) dj

  pure elemental function sub_aa(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x, y
    type(adjac_double) :: z

    z%value = x%value - y%value
    call alloc_mem_a(z, x%n + y%n)
    call sum_taylor(dble(1d0), dble(-1d0), x, y, z)
  end function sub_aa

  pure elemental function sub_ai(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_double) :: z
    z%value = x%value - y
    z%vmul = x%vmul
    call link_mem_a(z, x)
  end function sub_ai

  pure elemental function sub_ia(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_double) :: z
    z%value = x - y%value
    z%vmul = -y%vmul
    call link_mem_a(z, y)
  end function sub_ia
  pure elemental function sub_ad(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_double) :: z
    z%value = x%value - y
    z%vmul = x%vmul
    call link_mem_a(z, x)
  end function sub_ad

  pure elemental function sub_da(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_double) :: z
    z%value = x - y%value
    z%vmul = -y%vmul
    call link_mem_a(z, y)
  end function sub_da
  pure elemental function sub_az(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x - dble(y)
    z%im = -aimag(y)
  end function sub_az

  pure elemental function sub_za(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) - y
    z%im = aimag(x)
  end function sub_za

  pure elemental function sub_bb(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re - y%re
    z%im = x%im - y%im
  end function sub_bb

  pure elemental function sub_bz(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re - dble(y)
    z%im = x%im - aimag(y)
  end function sub_bz

  pure elemental function sub_zb(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) - y%re
    z%im = aimag(x) - y%im
  end function sub_zb

  pure elemental function sub_ba(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re - y
    z%im = x%im
  end function sub_ba

  pure elemental function sub_ab(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x - y%re
    z%im = -y%im
  end function sub_ab

  pure elemental function sub_bi(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_complex) :: z
    z = x - dcmplx(y)
  end function sub_bi

  pure elemental function sub_ib(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) - y
  end function sub_ib
  pure elemental function sub_bd(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_complex) :: z
    z = x - dcmplx(y)
  end function sub_bd

  pure elemental function sub_db(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) - y
  end function sub_db

  !!
  !! operator(-), unary
  !!

  pure elemental function neg_a(x) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_double) :: z
    z = 0d0 - x
  end function neg_a

  pure elemental function neg_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    z = (0d0,0d0) - x
  end function neg_b

  !!
  !! operator(*)
  !!

  ! X*Y = x*y + (x y_j + y x_j) dj

  pure elemental function mul_aa(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x, y
    type(adjac_double) :: z

    z%value = x%value * y%value
    call alloc_mem_a(z, x%n + y%n)
    call sum_taylor(y%value, x%value, x, y, z)
  end function mul_aa

  pure elemental function mul_ai(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_double) :: z
    if (y == 0) then
       z%value = 0
       z%vmul = 0
    else
       z%value = x%value * y
       z%vmul = x%vmul * y
       call link_mem_a(z, x)
    end if
  end function mul_ai

  pure elemental function mul_ia(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_double) :: z
    z = y * x
  end function mul_ia
  pure elemental function mul_ad(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_double) :: z
    if (y == 0) then
       z%value = 0
       z%vmul = 0
    else
       z%value = x%value * y
       z%vmul = x%vmul * y
       call link_mem_a(z, x)
    end if
  end function mul_ad

  pure elemental function mul_da(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_double) :: z
    z = y * x
  end function mul_da
  pure elemental function mul_az(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x * dble(y)
    z%im = x * aimag(y)
  end function mul_az

  pure elemental function mul_za(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) * y
    z%im = aimag(x) * y
  end function mul_za

  pure elemental function mul_bb(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re * y%re - x%im * y%im
    z%im = x%re * y%im + x%im * y%re
  end function mul_bb

  pure elemental function mul_bz(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re * dble(y) - x%im * aimag(y)
    z%im = x%re * aimag(y) + x%im * dble(y)
  end function mul_bz

  pure elemental function mul_zb(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) * y%re - aimag(x) * y%im
    z%im = dble(x) * y%im + aimag(x) * y%re
  end function mul_zb

  pure elemental function mul_ba(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re * y
    z%im = x%im * y
  end function mul_ba

  pure elemental function mul_ab(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x * y%re
    z%im = x * y%im
  end function mul_ab

  pure elemental function mul_bi(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_complex) :: z
    z = x * dcmplx(y)
  end function mul_bi

  pure elemental function mul_ib(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) * y
  end function mul_ib
  pure elemental function mul_bd(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_complex) :: z
    z = x * dcmplx(y)
  end function mul_bd

  pure elemental function mul_db(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) * y
  end function mul_db

  !!
  !! operator(/)
  !!

  ! X/Y = x/y + (x_j/y - x y_j/y**2) dj

  pure elemental function div_aa(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x, y
    type(adjac_double) :: z
    z%value = x%value / y%value
    call alloc_mem_a(z, x%n + y%n)
    call sum_taylor(1d0/y%value, -x%value/(y%value**2), x, y, z)
  end function div_aa

  pure elemental function div_ai(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_double) :: z
    z = (1d0 / y) * x
  end function div_ai

  pure elemental function div_ia(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_double) :: z
    z = (-x / (y%value**2)) * y
    z%value = x / y%value
  end function div_ia
  pure elemental function div_ad(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_double) :: z
    z = (1d0 / y) * x
  end function div_ad

  pure elemental function div_da(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_double) :: z
    z = (-x / (y%value**2)) * y
    z%value = x / y%value
  end function div_da
  pure elemental function div_az(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    double complex :: q
    q = conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
    z%re = dble(q) * x
    z%im = aimag(q) * x
  end function div_az

  pure elemental function div_za(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_complex) :: z
    z%re = dble(x) / y
    z%im = aimag(x) / y
  end function div_za

  pure elemental function div_bb(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = x * conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
  end function div_bb

  pure elemental function div_bz(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complex) :: z
    z = x * conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
  end function div_bz

  pure elemental function div_zb(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = x * conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
  end function div_zb

  pure elemental function div_ba(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_double), intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re / y
    z%im = x%im / y
  end function div_ba

  pure elemental function div_ab(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = x * conjg(y) / (dble(y)*dble(y) + aimag(y)*aimag(y))
  end function div_ab

  pure elemental function div_bi(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re / y
    z%im = x%im / y
  end function div_bi

  pure elemental function div_ib(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) / y
  end function div_ib
  pure elemental function div_bd(x, y) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_complex) :: z
    z%re = x%re / y
    z%im = x%im / y
  end function div_bd

  pure elemental function div_db(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_complex), intent(in) :: y
    type(adjac_complex) :: z
    z = dcmplx(x) / y
  end function div_db

  !!
  !! operator(**)
  !!

  pure elemental function pow_ai(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_double) :: z
    z = exp(y * log(x))
  end function pow_ai
  pure elemental function pow_ad(x, y) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_double) :: z
    z = exp(y * log(x))
  end function pow_ad

  !!
  !! matmul
  !!

  function matmul_aa(x, y) result(z)
    implicit none
    type(adjac_double), dimension(:,:), intent(in) :: x, y
    type(adjac_double), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_aa

  function matmul_ai(x, y) result(z)
    implicit none
    type(adjac_double), dimension(:,:), intent(in) :: x
    integer, dimension(:,:), intent(in) :: y
    type(adjac_double), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_ai

  function matmul_ia(x, y) result(z)
    implicit none
    integer, dimension(:,:), intent(in) :: x
    type(adjac_double), dimension(:,:), intent(in) :: y
    type(adjac_double), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_ia
  function matmul_ad(x, y) result(z)
    implicit none
    type(adjac_double), dimension(:,:), intent(in) :: x
    double precision, dimension(:,:), intent(in) :: y
    type(adjac_double), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_ad

  function matmul_da(x, y) result(z)
    implicit none
    double precision, dimension(:,:), intent(in) :: x
    type(adjac_double), dimension(:,:), intent(in) :: y
    type(adjac_double), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_da
  function matmul_bb(x, y) result(z)
    implicit none
    type(adjac_complex), dimension(:,:), intent(in) :: x, y
    type(adjac_complex), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_bb

  function matmul_bz(x, y) result(z)
    implicit none
    type(adjac_complex), dimension(:,:), intent(in) :: x
    double complex, dimension(:,:), intent(in) :: y
    type(adjac_complex), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_bz

  function matmul_zb(x, y) result(z)
    implicit none
    double complex, dimension(:,:), intent(in) :: x
    type(adjac_complex), dimension(:,:), intent(in) :: y
    type(adjac_complex), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_zb

  !!
  !! dble
  !!

  pure elemental function dble_a(x) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_double) :: z
    z = x
  end function dble_a

  pure elemental function dble_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_double) :: z
    z = x%re
  end function dble_b

  !!
  !! aimag
  !!

  pure elemental function aimag_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_double) :: z
    z = x%im
  end function aimag_b

  !!
  !! conjg
  !!

  pure elemental function conjg_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    z%re = x%re
    z%im = -x%im
  end function conjg_b

  !!
  !! exp
  !!

  pure elemental function exp_a(x) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_double) :: z
    double precision :: v, dv
    v = exp(x%value)
    dv = v
    z = dv*x
    z%value = v
  end function exp_a

  pure elemental function exp_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    double complex :: v, dv
    v = exp(dcmplx(x%re%value, x%im%value))
    dv = v
    z = dv*x
    z%re%value = dble(v)
    z%im%value = aimag(v)
  end function exp_b

  !!
  !! sin
  !!

  pure elemental function sin_a(x) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_double) :: z
    double precision :: v, dv
    v = sin(x%value)
    dv = cos(x%value)
    z = dv*x
    z%value = v
  end function sin_a

  pure elemental function sin_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    double complex :: v, dv
    v = sin(dcmplx(x%re%value, x%im%value))
    dv = cos(dcmplx(x%re%value, x%im%value))
    z = dv*x
    z%re%value = dble(v)
    z%im%value = aimag(v)
  end function sin_b

  !!
  !! cos
  !!

  pure elemental function cos_a(x) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_double) :: z
    double precision :: v, dv
    v = cos(x%value)
    dv = -sin(x%value)
    z = dv*x
    z%value = v
  end function cos_a

  pure elemental function cos_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    double complex :: v, dv
    v = cos(dcmplx(x%re%value, x%im%value))
    dv = -sin(dcmplx(x%re%value, x%im%value))
    z = dv*x
    z%re%value = dble(v)
    z%im%value = aimag(v)
  end function cos_b

  !!
  !! log
  !!

  pure elemental function log_a(x) result(z)
    implicit none
    type(adjac_double), intent(in) :: x
    type(adjac_double) :: z
    double precision :: v, dv
    v = log(x%value)
    dv = 1d0/x%value
    z = dv*x
    z%value = v
  end function log_a

  pure elemental function log_b(x) result(z)
    implicit none
    type(adjac_complex), intent(in) :: x
    type(adjac_complex) :: z
    double complex :: v, dv
    v = log(dcmplx(x%re%value, x%im%value))
    dv = 1d0/dcmplx(x%re%value, x%im%value)
    z = dv*x
    z%re%value = dble(v)
    z%im%value = aimag(v)
  end function log_b
  pure subroutine alloc_mem_q(x, n)
    implicit none
    type(adjac_complexan), intent(inout) :: x
    integer, intent(in) :: n

    if (jac_product_mode) then
       return
    end if
    x%n = n
    allocate(x%i(n), x%v(n))
  end subroutine alloc_mem_q

  pure subroutine link_mem_q(dst, src)
    implicit none
    type(adjac_complexan), intent(inout) :: dst
    type(adjac_complexan), intent(in) :: src
    dst%n = src%n
    if (src%n > 0) then
       dst%v = src%v
       dst%i = src%i
    end if
  end subroutine link_mem_q

  pure subroutine free_mem_q(x)
    implicit none
    type(adjac_complexan), intent(inout) :: x
    if (x%n > 0) then
       deallocate(x%v)
       deallocate(x%i)
    end if
    x%n = 0
  end subroutine free_mem_q

  subroutine set_independent_q(x, xval, j, dx)
    implicit none
    type(adjac_complexan), intent(out) :: x
    double complex, intent(in) :: xval
    double complex, optional, intent(in) :: dx
    integer, intent(in) :: j

    x%value = xval
    if (jac_product_mode) then
       if (.not.present(dx)) then
          call fatal_error('no dx given to adjac_set_independent when jacobian product mode is active')
       end if
       x%vmul = dx
    else
       x%vmul = 1
       call alloc_mem_q(x, 1)
       x%v(1) = 1
       x%i(1) = j
    end if
  end subroutine set_independent_q

  subroutine set_independent_many_q(x, xval, dx)
    implicit none
    type(adjac_complexan), dimension(:), intent(inout) :: x
    double complex, dimension(size(x)), intent(in) :: xval
    double complex, dimension(size(x)), optional, intent(in) :: dx

    integer :: j

    if (present(dx)) then
       do j = 1, size(x,1)
          call set_independent_q(x(j), xval(j), j, dx(j))
       end do
    else
       do j = 1, size(x,1)
          call set_independent_q(x(j), xval(j), j)
       end do
    end if
  end subroutine set_independent_many_q

  subroutine get_value_one_q(y, val, dy)
    implicit none
    type(adjac_complexan), intent(in) :: y
    double complex, intent(out) :: val
    double complex, optional, intent(out) :: dy
    val = y%value
    if (present(dy)) then
       if (.not. jac_product_mode) then
          call fatal_error('call to adjac_get_value with dy when jacobian product mode is not active')
       end if
       dy = y%vmul
    end if
  end subroutine get_value_one_q

  subroutine get_value_many_q(y, val, dy)
    implicit none
    type(adjac_complexan), dimension(:), intent(in) :: y
    double complex, dimension(size(y,1)), intent(out) :: val
    double complex, dimension(size(y,1)), optional, intent(out) :: dy
    integer :: j
    do j = 1, size(val,1)
       val(j) = y(j)%value
    end do
    if (present(dy)) then
       if (.not. jac_product_mode) then
          call fatal_error('call to adjac_get_value with dy when jacobian product mode is not active')
       end if
       do j = 1, size(val,1)
          dy(j) = y(j)%vmul
       end do
    end if
  end subroutine get_value_many_q

  subroutine get_dense_jacobian_q(y, jac_dense)
    implicit none
    type(adjac_complexan), dimension(:), intent(inout) :: y
    double complex, dimension(:,:), intent(out) :: jac_dense
    integer :: i, p

    if (jac_product_mode) then
       call fatal_error('call to adjac_get_dense_jacobian when jacobian product mode is active')
    end if

    jac_dense = 0

    do i = 1, size(y,1)
       do p = 1, y(i)%n
          jac_dense(i, y(i)%i(p)) = jac_dense(i, y(i)%i(p)) &
               + y(i)%vmul * y(i)%v(p)
       end do
    end do
  end subroutine get_dense_jacobian_q

  subroutine get_coo_jacobian_q(y, jac_val, jac_i, jac_j)
    implicit none
    type(adjac_complexan), dimension(:), intent(inout) :: y
    double complex, dimension(:), allocatable, intent(inout) :: jac_val
    integer, dimension(:), allocatable, intent(inout) :: jac_i, jac_j
    integer :: i, k, nnz

    if (jac_product_mode) then
       call fatal_error('call to adjac_get_coo_jacobian when jacobian product mode is active')
    end if

    if (allocated(jac_val)) deallocate(jac_val)
    if (allocated(jac_i)) deallocate(jac_i)
    if (allocated(jac_j)) deallocate(jac_j)

    nnz = sum(y%n)

    allocate(jac_val(nnz), jac_i(nnz), jac_j(nnz))

    k = 1
    do i = 1, size(y,1)
       if (y(i)%n > 0) then
          jac_i(k:k+y(i)%n-1) = i
          jac_j(k:k+y(i)%n-1) = y(i)%i(1:y(i)%n)
          jac_val(k:k+y(i)%n-1) = y(i)%vmul * y(i)%v(1:y(i)%n)
          k = k + y(i)%n
       end if
    end do
  end subroutine get_coo_jacobian_q

  pure subroutine sum_taylor_q(alphap, betap, a, b, c)
    ! c := alpha*a + beta*b
    use iso_c_binding
    implicit none
    double complex, intent(in) :: alphap, betap
    type(adjac_complexan), intent(in) :: a, b
    type(adjac_complexan), intent(inout) :: c
    interface
       pure subroutine sparse_vector_sum_q(alpha, beta, na, nb, nc, ia, ib, ic, va, vb, vc) &
            bind(C,name="sparse_vector_sum_q")
         use iso_c_binding
         integer(kind=c_int), intent(in) :: na, nb, ia(*), ib(*)
         integer(kind=c_int), intent(inout) :: nc
         integer(kind=c_int), intent(out) :: ic(*)
         complex(kind=c_double_complex), intent(in) :: alpha, beta, va(*), vb(*)
         complex(kind=c_double_complex), intent(out) :: vc(*)
       end subroutine sparse_vector_sum_q
    end interface

    if (jac_product_mode) then
       c%vmul = alphap * a%vmul + betap * b%vmul
    else
       call sparse_vector_sum_q(alphap*a%vmul, betap*b%vmul, a%n, b%n, c%n, &
            a%i, b%i, c%i, &
            a%v, b%v, c%v)
       c%vmul = 1
    end if
  end subroutine sum_taylor_q

  
  !--------------------------------------------------------------------------
  ! Overloaded operators
  !--------------------------------------------------------------------------

  !!
  !! assignment(=)
  !!

  pure elemental subroutine assign_qi(x, y)
    implicit none
    type(adjac_complexan), intent(inout) :: x
    integer, intent(in) :: y
    call free_mem_q(x)
    x%value = y
    x%vmul = 0
  end subroutine assign_qi
  pure elemental subroutine assign_qd(x, y)
    implicit none
    type(adjac_complexan), intent(inout) :: x
    double precision, intent(in) :: y
    call free_mem_q(x)
    x%value = y
    x%vmul = 0
  end subroutine assign_qd
  pure elemental subroutine assign_qz(x, y)
    implicit none
    type(adjac_complexan), intent(inout) :: x
    double complex, intent(in) :: y
    call free_mem_q(x)
    x%value = y
    x%vmul = 0
  end subroutine assign_qz

  !!
  !! operator(+)
  !!

  ! X + Y = x + y + (x_j + y_j) dj

  pure elemental function add_qq(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x, y
    type(adjac_complexan) :: z

    z%value = x%value + y%value
    call alloc_mem_q(z, x%n + y%n)
    call sum_taylor(dcmplx(1d0), dcmplx(1d0), x, y, z)
  end function add_qq

  pure elemental function add_qi(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_complexan) :: z
    z%value = x%value + y
    z%vmul = x%vmul
    call link_mem_q(z, x)
  end function add_qi

  pure elemental function add_iq(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z = y + x
  end function add_iq
  pure elemental function add_qd(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_complexan) :: z
    z%value = x%value + y
    z%vmul = x%vmul
    call link_mem_q(z, x)
  end function add_qd

  pure elemental function add_dq(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z = y + x
  end function add_dq
  pure elemental function add_qz(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complexan) :: z
    z%value = x%value + y
    z%vmul = x%vmul
    call link_mem_q(z, x)
  end function add_qz

  pure elemental function add_zq(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z = y + x
  end function add_zq

  !!
  !! operator(+), unary
  !!

  pure elemental function pos_q(x) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    type(adjac_complexan) :: z
    z = x
  end function pos_q


  !!
  !! operator(-)
  !!

  ! X - Y = x - y + (x_j - y_j) dj

  pure elemental function sub_qq(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x, y
    type(adjac_complexan) :: z

    z%value = x%value - y%value
    call alloc_mem_q(z, x%n + y%n)
    call sum_taylor(dcmplx(1d0), dcmplx(-1d0), x, y, z)
  end function sub_qq

  pure elemental function sub_qi(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_complexan) :: z
    z%value = x%value - y
    z%vmul = x%vmul
    call link_mem_q(z, x)
  end function sub_qi

  pure elemental function sub_iq(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z%value = x - y%value
    z%vmul = -y%vmul
    call link_mem_q(z, y)
  end function sub_iq
  pure elemental function sub_qd(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_complexan) :: z
    z%value = x%value - y
    z%vmul = x%vmul
    call link_mem_q(z, x)
  end function sub_qd

  pure elemental function sub_dq(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z%value = x - y%value
    z%vmul = -y%vmul
    call link_mem_q(z, y)
  end function sub_dq
  pure elemental function sub_qz(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complexan) :: z
    z%value = x%value - y
    z%vmul = x%vmul
    call link_mem_q(z, x)
  end function sub_qz

  pure elemental function sub_zq(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z%value = x - y%value
    z%vmul = -y%vmul
    call link_mem_q(z, y)
  end function sub_zq

  !!
  !! operator(-), unary
  !!

  pure elemental function neg_q(x) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    type(adjac_complexan) :: z
    z = 0d0 - x
  end function neg_q


  !!
  !! operator(*)
  !!

  ! X*Y = x*y + (x y_j + y x_j) dj

  pure elemental function mul_qq(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x, y
    type(adjac_complexan) :: z

    z%value = x%value * y%value
    call alloc_mem_q(z, x%n + y%n)
    call sum_taylor(y%value, x%value, x, y, z)
  end function mul_qq

  pure elemental function mul_qi(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_complexan) :: z
    if (y == 0) then
       z%value = 0
       z%vmul = 0
    else
       z%value = x%value * y
       z%vmul = x%vmul * y
       call link_mem_q(z, x)
    end if
  end function mul_qi

  pure elemental function mul_iq(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z = y * x
  end function mul_iq
  pure elemental function mul_qd(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_complexan) :: z
    if (y == 0) then
       z%value = 0
       z%vmul = 0
    else
       z%value = x%value * y
       z%vmul = x%vmul * y
       call link_mem_q(z, x)
    end if
  end function mul_qd

  pure elemental function mul_dq(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z = y * x
  end function mul_dq
  pure elemental function mul_qz(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complexan) :: z
    if (y == 0) then
       z%value = 0
       z%vmul = 0
    else
       z%value = x%value * y
       z%vmul = x%vmul * y
       call link_mem_q(z, x)
    end if
  end function mul_qz

  pure elemental function mul_zq(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z = y * x
  end function mul_zq

  !!
  !! operator(/)
  !!

  ! X/Y = x/y + (x_j/y - x y_j/y**2) dj

  pure elemental function div_qq(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x, y
    type(adjac_complexan) :: z
    z%value = x%value / y%value
    call alloc_mem_q(z, x%n + y%n)
    call sum_taylor(1d0/y%value, -x%value/(y%value**2), x, y, z)
  end function div_qq

  pure elemental function div_qi(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_complexan) :: z
    z = (1d0 / y) * x
  end function div_qi

  pure elemental function div_iq(x, y) result(z)
    implicit none
    integer, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z = (-x / (y%value**2)) * y
    z%value = x / y%value
  end function div_iq
  pure elemental function div_qd(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_complexan) :: z
    z = (1d0 / y) * x
  end function div_qd

  pure elemental function div_dq(x, y) result(z)
    implicit none
    double precision, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z = (-x / (y%value**2)) * y
    z%value = x / y%value
  end function div_dq
  pure elemental function div_qz(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complexan) :: z
    z = (1d0 / y) * x
  end function div_qz

  pure elemental function div_zq(x, y) result(z)
    implicit none
    double complex, intent(in) :: x
    type(adjac_complexan), intent(in) :: y
    type(adjac_complexan) :: z
    z = (-x / (y%value**2)) * y
    z%value = x / y%value
  end function div_zq

  !!
  !! operator(**)
  !!

  pure elemental function pow_qi(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    integer, intent(in) :: y
    type(adjac_complexan) :: z
    z = exp(y * log(x))
  end function pow_qi
  pure elemental function pow_qd(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double precision, intent(in) :: y
    type(adjac_complexan) :: z
    z = exp(y * log(x))
  end function pow_qd
  pure elemental function pow_qz(x, y) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    double complex, intent(in) :: y
    type(adjac_complexan) :: z
    z = exp(y * log(x))
  end function pow_qz

  !!
  !! matmul
  !!

  function matmul_qq(x, y) result(z)
    implicit none
    type(adjac_complexan), dimension(:,:), intent(in) :: x, y
    type(adjac_complexan), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_qq

  function matmul_qi(x, y) result(z)
    implicit none
    type(adjac_complexan), dimension(:,:), intent(in) :: x
    integer, dimension(:,:), intent(in) :: y
    type(adjac_complexan), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_qi

  function matmul_iq(x, y) result(z)
    implicit none
    integer, dimension(:,:), intent(in) :: x
    type(adjac_complexan), dimension(:,:), intent(in) :: y
    type(adjac_complexan), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_iq
  function matmul_qd(x, y) result(z)
    implicit none
    type(adjac_complexan), dimension(:,:), intent(in) :: x
    double precision, dimension(:,:), intent(in) :: y
    type(adjac_complexan), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_qd

  function matmul_dq(x, y) result(z)
    implicit none
    double precision, dimension(:,:), intent(in) :: x
    type(adjac_complexan), dimension(:,:), intent(in) :: y
    type(adjac_complexan), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_dq
  function matmul_qz(x, y) result(z)
    implicit none
    type(adjac_complexan), dimension(:,:), intent(in) :: x
    double complex, dimension(:,:), intent(in) :: y
    type(adjac_complexan), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_qz

  function matmul_zq(x, y) result(z)
    implicit none
    double complex, dimension(:,:), intent(in) :: x
    type(adjac_complexan), dimension(:,:), intent(in) :: y
    type(adjac_complexan), dimension(size(x,1),size(y,2)) :: z
        integer i, j, k

    if (size(x,2) .ne. size(y,1)) then
       write(*,*) 'invalid array sizes in matmul'
       stop
    end if

    do j = 1, size(y,2)
       do i = 1, size(x,1)
          z(i,j) = x(i,1)*y(1,j)
          do k = 2, size(x,2)
             z(i,j) = z(i,j) + x(i,k)*y(k,j)
          end do
       end do
    end do

  end function matmul_zq

  !!
  !! dble
  !!


  !!
  !! aimag
  !!


  !!
  !! conjg
  !!


  !!
  !! exp
  !!

  pure elemental function exp_q(x) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    type(adjac_complexan) :: z
    double complex :: v, dv
    v = exp(x%value)
    dv = v
    z = dv*x
    z%value = v
  end function exp_q


  !!
  !! sin
  !!

  pure elemental function sin_q(x) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    type(adjac_complexan) :: z
    double complex :: v, dv
    v = sin(x%value)
    dv = cos(x%value)
    z = dv*x
    z%value = v
  end function sin_q


  !!
  !! cos
  !!

  pure elemental function cos_q(x) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    type(adjac_complexan) :: z
    double complex :: v, dv
    v = cos(x%value)
    dv = -sin(x%value)
    z = dv*x
    z%value = v
  end function cos_q


  !!
  !! log
  !!

  pure elemental function log_q(x) result(z)
    implicit none
    type(adjac_complexan), intent(in) :: x
    type(adjac_complexan) :: z
    double complex :: v, dv
    v = log(x%value)
    dv = 1d0/x%value
    z = dv*x
    z%value = v
  end function log_q


end module adjac
